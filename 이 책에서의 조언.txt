단원 별로 적는다
[1]
1. 구상(개념)을 함수, 클래스, 열거형 등을 통해서 직접적으로 코드에 표현한다
2. 코드를 깔끔하고 효율적으로 만들겠다는 목표를 세운다
3. 과도한 추상화를 하지 않는다
4. 라이브러리로 표현될 가능성이 있는, 깔끔하고 효율적인 추상화를 제공하는 데 설게의 초점을 맞춘다
5. 매개변수화나 클래스 게층 구조 등을 통해 아이디어 사이의 관게를 직접적으로 코드에 표현한다
6. 독립적인 아이디어는 코드에 개별적으로 표현한다. 예를 들어 클래스 간의 상호 의존성은 피한다
7. C++는 객체지향적이지만은 않다
8. C++는 일반화 프로그래밍을 위한 것만은 아니다
9. 정적으로 체크할 수 있는 해결책을 우선 사용한다
10. 자원은 명시적으로 표시한다(즉 클래스 객체로 표현한다)
11. 간단한 아이디어는 간단히 표현한다
12. 밑바닥에서부터 모든 것을 만들려고 얘쓰지 말고 라이브러리, 그 중에서도 특히 표준 라이브러리를 활용한다
13. 타입이 풍부한 프로그래밍 스타일을 활용한다
14. 저수준의 코드가 반드시 효율적이지는 않다. 성능 문제에 대한 염려 때문에 클래스 템플릿, 표준 라이브러리 구성 요소의 사용을 주저하지 않는다
15. 데이터가 불변속성을 갖고 있다면 캡슐화한다
16. C++는 단지 몇 가지 확장 기능을 가진 C가 아니다

[2]
1. 당황하지 말자! 시간이 지나면 알게 된다
2. 휼횽한 프로그램을 작성하기 위해 C++의 세부 사항까지 전부 알 필요는 없다
3. 언어 기능이 아니라 프로그래밍 기법에 집중하자

[3]
1. 아이디어를 직접적으로 코드에 표현한다
2. 응용 개념을 직접적으로 코드에 표현해주는 클래스를 정의한다
3. 구체 클래스를 이용해서 간단한 개념과 성능이 중요한 구성 요소를 표현한다
4. '무방비'의 new와 delete 연산은 피한다
5. 자원 핸들과 RAII를 이용해서 자원을 관리한다
6. 인터페이스와 구현의 완벽한 분리가 필요할 때는 추상 클래스를 인터페이스로 활용한다
7. 클래스 계층 구조를 이용해서 내재적인 게층 구조를 가진 개념을 표현한다
8. 클래스 계층 구조를 설계할 때는 구현 상속과 인터페이스 상속을 구분한다
9. 객체의 복사, 이동, 소멸을 통제한다
10. 컨테이너는 값으로 반환한다(효율성이 중요하다면 move를 이용한다)
11. 강력한 자원 안정성을 제공한다. 즉, 자원이라고 여겨지는 것이라면 절대로 누출시키지 않는다
12. 자원 핸들 템플릿으로 정의된 컨테이너를 이용해서 동일한 타입의 값으로 이뤄진 집합을 보관한다
13. 함수 템플릿을 이용해서 일반적인 알고리즘을 표현한다
14. 람다를비롯한 함수 객체를 이용해서 정책과 자동을 표현한다
15. 타입 및 템플릿 별칭을 이용해서 유사한 타입이나 구현에 따라 변할 수 있는 타입에 대해 동일한 이름을 부여한다

[4]
1. 바퀴를 다시 필요는 없다. 라이브러리를 활용한다
2. 선택 가능할 경우에는 다른 라이브러리보다 표준 라이브러리를 우선 사용한다
3. 표준 라이브러리가 만능이라고 생각하지는 말기 바란다
4. 사용하려는 기능에 대한 혜더를 #include하는 것을 잊지 않는다
5. 표준 라이브러리 기능은 std 네임스페이스 범위로 정의된다는 점을 명심한다
6. C 스타일 문자열(char*)보다 string을 우선 사용한다
7. istream은 타입을 구분하고, 타입 안전성이 있으며, 확장성이 있다
8. T[]보다 vector<T>, map<K, T>, unordered_map<K, T>를 우선 사용한다
9. 표준 컨테이너와 그들의 장단점을 파악한다
10.vector를 기본 컨테이너로 활용한다
11. 가급적 간결한 데이터 구조를 사용한다
12. 의심스럽다면 범위 체크 벡터(Vec 등의)를 사용한다
13. push_back() 또는 back_inserter()를 사용해서 컨테이너에 원소를 사용한다
14. 배열에 realloc()을 사용하지 않고, vector에 push_back()을 사용한다
15. 일반적인 예외는 main()에서 잡는다
16. 펴준 알고리즘을 파악해서 직접 만든 루프보다는 표준 알고리즘을 우선 사용한다
17. 반복자가 장황해지면 컨테이너 알고리즘을 정의한다
18. 완전한 컨테이너에 대해서는 범위 기반 for 루프를 사용한다

[5]
1. 자원 핸들을 이용해서 자원을 관리한다
2. unique_ptr을 이용해서 다형성 타입의 객체를 참조한다
3. shared_ptr을 이용해서 공유 객체를 참조한다
4. 병행성에 대해서는 타입 안전적인 메커니즘을 사용한다
5. 공유 데이터의 사용은 최소화한다
6. 심사숙고나 실제적인 측정 없이 '효율성'이란 이유 때문에 통신을 위해 공유 데이터를 선택하지 말기 바란다
7. 스레드보다 병행 태스크의 관점에서 생각한다
8. 라이브러리는 규모가 크거나 복잡하지 않아도 쓸모가 있을 수 있다
9. 효율성에 대해서 주장하기 전에 자신의 프로그램을 측정해봐야 한다
10. 타입 속성에 명시적으로 의존하는 코드를 작성할 수 있다
11. 간단한 패턴 매칭을 위해서는 정규 표현식을 사용한다
12. 언어만 사용해서 본격적인 수치 게산을 처리하고 시도하지 않는다. 라이브러리를 활용한다
13. 수치 타입의 속성은 numeric_limits를 통해 접근할 수 있다

[6]
1. 언어 정의 이슈에 대한 최종 결정 사항은 ISO C++ 표준을 참고한다
2. 지정되지 않거나 정의되지 않은 동작은 삼간다
3. 구현별 정의에 따르는 동작에는 반드시 의존하는 코드는 격리한다
4. 문자의 수치 값에 대한 불필요한 추정은 삼간다
5. 0으로 시작하는 정수는 8진수라는 점을 명심한다
6. '마법의 상수'는 피한다
7. 정수의 크기에 대한 불필요한 추정은 삼간다
8. 부동소수점 타입의 범위와 정밀도에 대한 불필요한 추정은 삼간다
9. signed char나 unsigned보다 일반적인 char가 낫다
10. 부호 있는 타입과 부호 없는 타입 간의 변환은 조심한다
11. 하나의 선언에서는 하나의 이름만 선언한다
12. 통상적인 이름과 지역 이름은 짧게 만들고, 자주 사용되지 않는 이름과 비지역 이름은 길게 만든다
13. 이름은 비슷하게 만들지 않는다
14. 타입보다는 의미에 맞춰 객체에 이름을 붙인다
15. 일관된 명명 규칙을 준수한다
16. ALL_CAPS 이름을 피한다
17. 유효 범위는 가급적 좁게 만든다
18. 하나의 유효 범위 내에서뿐만 아니라 이를 둘러싼 바깥 유효 범위 내에서도 같은 이름은 쓰지 않는다
19. 이름이 있는 타입을 가진 선언에 대해서는 {} 초기화 식 문법을 사용하는 것이 좋다
20. auto를 사용하는 선언에서는 초기화에 = 문법을 사용하는 것이 좋다
21. 초기화되지 않는 변수는 삼간다
22. 기본 제공 타입이 변경될 수 있는 값을 표시하는 데 사용된 경우에는 기본 제공 타입에 의미 있는 이름을 붙이기 위해 별칭을 사용한다
23. 별칭은 다른 타입을 다른 이름으로 표시하고 싶을 때 사용한다. 새로운 타입을 정의하고 싶다면 열거형과 클래스를 이용한다

[7]
1. 포인터는 간결하고 직관적으로 활용한다
2. 허용되지 않는 포인터 연산은 삼간다
3. 경게 배열 너머에 쓰지 않도록 조심한다
4. 다차원 배열을 피한다. 대신 적절한 컨테이너를 정의한다
5. 0이나 NULL보다 nullptr을 이용한다
6. 기본 제공 C 스타일의 배열보다 컨테이너(vector, array, valarray)를 이용한다
7. 0으로 종료되는 char의 배열보다 string을 이용한다
8. 백슬래시를 복잡하게 사용하는 문자열 리터럴에는 원시 문자열을 이용한다
9. 보통의 참조자 인자보다 const 참조자 인자를 선택한다
10. 포워딩과 이동 의미 구조에만 우변 값 참조자를 이용한다
11. 소유권을 표시하는 포인터는 핸들 클래스 내부에 둔다
12. 저수준의 코드를 제외하고는 void*를 삼간다
13. 인터페이스에서 불변성을 표현하기 위해 const 포인터와 const 참조자를 이용한다
14. '객체 없음'이 타당한 선택인 경우를 제외하고는 포인터보다는 참조자를 인자로 선택한다

[8]
1. 데이터 용량의 최소화가 필요한 경우에는 구조체의 큰 멤버들을 작은 멤버들보다 앞에 배치하도록 한다
2. 하드웨어의 구조를 나타내는 데이터 구조를 표시하려면 비트필드를 활용한다
3. 여러 개의 값을 하나의 바이트에 구겨 넣는 단순한 방식으로 메모리 소비를 최적화하려고 시도하지 말기 바란다
4. union은 메모리 공간 절약에 활용하고 타입 변환에는 이용하지 않는다
5. 열거형을 이용해서 이름 있는 상수 집합을 표시한다
6. 예기치 않은 결과를 최소화하기 위해 '일반'enum보다 enum class를 사용한다
7. 안전하고 간편한 활용을 위해 열거형에 대해 연산을 정의한다

[9]
1. 초기화할 수 있는 값이 생기기 전에는 변수 선언을 삼간다
2. 가능하다면 if문보다 switch문을 사용한다
3. 가능하다면 for문보다 범위 기반 for문을 사용한다
4. 명확한 루프 변수가 있는 경우에는 while문보다 for문을 사용한다
5. 명확한 루프 변수가 없는 경우에는 for문보다 while문을 사용한다
6. do문은 피한다
7. goto문은 피한다
8. 주석은 간결하게 유지한다
9. 코드를 보면 명확히 할 수 있는 상항은 주석에 적지 않는다
10. 주석에 의도를 설명한다
11. 일관된 들여쓰기 스타일을 유지한다

[10]
1. 다른 라이브러리나 '직접 짠 코드'보다 표준 라이브러리를 우선 사용한다
2. 문자 수준의 입력은 어쩔 수 없을 때만 사용한다
3. 읽기를 수행할 때는 언제나 형식이 맞지 않는 입력을 고려한다
4. 언어 기능을 직접적으로 이용하기보다는 적합한 추상화를 우선 사용한다
5. 복잡한 표현식을 피한다
6. 연산자 우선순위에 대해 의심이 생긴다면 괄호를 친다
7. 정의되지 않은 평가 순서를 가진 표현식은 피한다
8. 축소 변환은 피한다
9. '매직 상수'를 피하기 위해 기호 상수를 정의한다

[11]
1. 접미사 ++보다 접두사 ++를 우선 사용한다
2. 자원 핸들을 이용해서 누출, 때 이른 소멸, 이중 소멸은 피한다
3. 꼭 그럴 필요가 없다면 객체를 자유 저장 공간에 넣지 않는다. 유효 범위를 가진 변수를 우선 사용한다
4. '무방비의 new'나 '무방비의 delete'는 피한다
5. RAII를 사용한다
6. 연산이 주석을 필요로 하는 경우라면 람다보다 이름을 가진 함수 객체를 우선 사용한다
7. 연산이 범용적으로 유용하다면 람다보다 이름을 가진 함수 객체를 우선 사용한다
8. 람다는 짧게 만든다
9. 유지 보수성과 정확성을 위해 참조자에 의한 캡처에 대해서는 신중을 가한다
10. 컴파일러가 람다의 반한 타입을 추론하게 만든다
11. 생성에는 T{e} 표기법을 사용한다
12. 명시적 타입 변환은 피한다
13. 명시적 타입 변환이 필요한 경우에는 이름 있는 캐스트를 우선 사용한다
14. 수치 타입 간의 변환에는 narrow_cast<>() 같은 런타임 체크 캐스트의 사용을 고려한다

[12]
1. 의미 있는 연산은 신중하게 이름을 붙인 함수로 '패키지'를 만든다
2. 함수는 단일한 논리 연산을 수행해야 한다
3. 함수는 짧게 만든다
4. 지역 변수를 가리키는 포인터나 지역 변수에 대한 참조자는 반환하지 않는다
5. 어떤 함수가 컴파일 타임에 평가돼야 한다면 constexpr로 선언한다
6. 어떤 함수가 반환할 수 없다면 [[noreturn]]으로 표시한다
7. 작은 객체에 대해서는 값에 의한 전달을 사용한다
8. 변경할 필요가 없는 큰 값을 전달할 때는 const 참조자에 의한 전달을 사용한다
9. 인자를 통해 객체를 변경하기보다는 return 값으로서 결과를 반환한다
10. 이동과 전달을 구현하려면 우변 값 참조자를 사용한다
11. '객체 없음'이 유효한 대안인 경우에는 포인터를 전달한다
12. 그럴 필요가 있을 때만 const가 아닌 참조자에 의한 전달을 사용한다
13. const를 광범위하고 일관성 있게 사용한다
14. char* const char* 인자는 C 스타일 문자열을 가리킨다고 가정한다
15. 배열을 포인터로 전달하는 것은 피한다
16. 길이를 모르는 균일한 리스트는 initializer_list<T>로 전달한다
17. 지정되지 않은 인자의 개수(...)는 피한다
18. 함수가 서로 다른 타입에 개념적으로 동일한 작업을 수행할 때는 오버로딩을 활용한다
19. 정수에 대해 오버로딩을 할 경우에는 일반적인 모호성을 제거해 주는 함수를 제공한다
20. 함수에 대해 선행 조건과 후행 조건을 지정한다
21. 함수를 가리키는 포인터보다 함수 객체와 가상 함수를 우선적으로 사용한다
22. 매크로는 피한다
23. 매크로를 사용해야 한다면 대문자를 많이 가진 이상해 보이는 이름을 사용한다

